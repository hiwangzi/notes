# MySQL 事务

## ACID

ACID 是数据库事务正确性的四个主要特性的首字母缩写，包括：

- **原子性（Atomicity）**：原子性意味着事务是一个不可分割的工作单位，事务中包含的操作要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

- **一致性（Consistency）**：一致性保证事务必须使数据库从一个一致性状态变换到另一个一致性状态。一致性与业务规则有关，业务规则可能涉及到数据的一些约束条件。例如，在转账业务中，不论转账是否成功，转账前后两个账户的总金额是相同，保持了一致性。

- **隔离性（Isolation）**：多个事务并发执行时，事务之间是隔离的，即一个事务不应当影响其他事务的运行。对于任意两个并发的事务 T1 和 T2，在 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后开始，这使得每个事务都感觉不到系统中有其他事务在并发地执行。

- **持久性（Durability）**：一旦事务提交，对数据的修改就是永久性的，即使在系统崩溃的情况下，修改的数据也不会丢失。

这四个特性是大多数数据库管理系统（例如 MySQL、PostgreSQL、Oracle 等）为了确保数据正确性和完整性而必须提供的。ACID 属性可以确保数据的一致性和完整性，即使在多个用户并发访问数据或者系统发生故障的情况下。

## 隔离性的实现

并发隔离性在数据库系统中主要是通过事务管理和各种锁定机制来实现的。以下是一些常用的隔离机制：

1. **锁定（Locking）**：这是最基本的并发控制技术之一，通过对数据对象加锁，可以让一个事务独占该数据对象。有两种基本类型的锁：共享锁（Shared Lock）和排他锁（Exclusive Lock）。共享锁允许多个事务读取（但不能修改）同一数据项，而排他锁则允许一个事务独占数据项，进行读取和修改操作。

2. **多版本并发控制（Multiversion Concurrency Control, MVCC）**：MVCC 是一种更高级的并发控制技术，它通过为每个操作的数据对象创建版本（"快照"）来实现。在 MVCC 中，读操作不会阻塞写操作，写操作也不会阻塞读操作，因此它可以提供比锁定更高的并发性能。

3. **优化读取（Read Optimized）**：这是另一种并发控制技术，通过在读取数据时复制一份数据的副本，使得读操作不会被写操作影响。然而，这种方法可能会带来一致性问题，因为读取到的可能是旧的数据副本。

4. **锁定粒度（Lock Granularity）**：锁定粒度描述的是锁定对象的大小和级别，可以是数据库、表、页或行。通常，更小的锁定粒度可以提供更好的并发性能，但管理这些锁的开销也会更大。

5. **事务隔离级别（Transaction Isolation Levels）**：SQL 标准定义了四个事务隔离级别，包括读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。每个级别都有不同的并发性能和一致性保证。

请注意，一些数据库系统可能同时使用多种技术来实现并发隔离性。例如，PostgreSQL 使用 MVCC 来实现并发控制，而 MySQL 的 InnoDB 存储引擎则同时使用了锁定和 MVCC。

### 共享锁与排他锁

锁是数据库管理系统用于管理并发操作和保护数据完整性的主要工具。在数据库中，主要有两种类型的锁：共享锁（Shared Lock）和排他锁（Exclusive Lock）。

1. **共享锁（Shared Lock）**：共享锁用于读取操作，允许多个事务同时读取同一条数据。当一个事务对一条数据加上共享锁后，其他事务还可以对同一条数据加上共享锁进行读取操作，但不能加上排他锁进行写入操作。这就保证了在读取数据的过程中，数据不会被修改。

2. **排他锁（Exclusive Lock）**：排他锁用于写入操作，只允许一个事务对数据进行修改。当一个事务对一条数据加上排他锁后，其他事务不能对同一条数据加上共享锁或排他锁。这就保证了在修改数据的过程中，数据不会被其他事务同时读取或修改。

这两种锁都是为了保证数据的一致性和完整性。在实际操作中，通常会使用锁管理器来管理这些锁，决定何时加锁，何时释放锁，以及如何处理锁冲突。这些都是为了实现事务的隔离性，使得每个事务都像是在单独操作数据库一样。

### 锁的实际使用

在一些数据库系统（如MySQL的InnoDB存储引擎）中，默认采用的并发控制机制是多版本并发控制（MVCC），这种机制在大部分读取操作中并不需要使用锁，它可以通过创建和管理数据的多个版本来实现高并发性。

然而，在某些情况下，仍然需要使用共享锁或排他锁，比如在事务的隔离级别为“可重复读”（Repeatable Read）或“串行化”（Serializable）时，或者在明确执行锁定读操作（如SELECT ... FOR SHARE或SELECT ... FOR UPDATE）时。

`FOR SHARE`和`FOR UPDATE`都是SQL语句中用于锁定行的子句，它们在数据库事务管理中起着非常重要的作用。两者的主要区别在于锁的类型和锁定行为。

1. **FOR UPDATE**：当你在SQL查询中使用`FOR UPDATE`子句时，数据库会对选定的行加上排他锁（Exclusive Lock）。这意味着，只有这个事务才能修改这些行，其他事务必须等待直到这个事务完成（提交或回滚），才能对这些行进行修改或锁定。此外，其他事务在默认的隔离级别下也无法读取到这些被锁定的行，除非设置了较低的隔离级别（如READ UNCOMMITTED）。
2. **FOR SHARE**：当你在SQL查询中使用`FOR SHARE`子句时，数据库会对选定的行加上共享锁（Shared Lock）。这意味着，其他事务可以读取这些行，也可以对这些行加上共享锁，但不能加上排他锁进行修改，必须等待直到你的事务完成，才能进行修改。

在实际使用中，`FOR UPDATE`和`FOR SHARE`可以帮助你更好地控制并发操作，防止数据不一致或冲突。例如，`FOR UPDATE`常用于先读取数据，然后基于读取的数据进行修改的情况，如"读取-修改-写入"的操作，而`FOR SHARE`则可以用于需要防止数据在读取期间被修改的情况。

另外，即使在使用MVCC的数据库中，写操作（如UPDATE, DELETE, INSERT）通常也需要使用排他锁，来确保数据在写入过程中的一致性和完整性。

## 隔离等级

SQL标准定义了四个事务隔离级别，它们从低到高分别是：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。每个级别都有不同的并发性能和一致性保证，以下是对每个级别的具体介绍：

1. **读未提交（Read Uncommitted）**：这是最低的隔离级别。在这个级别，一个事务可以读取到其他事务未提交的修改。这可能导致脏读（Dirty Read，读取到其他事务未提交的修改）和不可重复读（Non-repeatable Read，在同一事务内多次读取同一数据返回不同结果）等问题。由于并发性能高，但数据一致性差，所以在需要高并发性能并且可以接受一定的数据不一致的场景下可能会使用，例如实时的股票交易系统。

2. **读已提交（Read Committed）**：在这个级别，一个事务只能读取到其他事务已提交的修改。这可以避免脏读问题，但仍可能导致不可重复读和幻读（Phantom Read，由于其他事务的插入或删除操作，导致同一事务多次查询返回的结果集不一致）问题。这是许多数据库系统的默认隔离级别，适用于大多数常规的业务场景。

3. **可重复读（Repeatable Read）**：在这个级别，同一事务多次读取同一数据将始终返回同样的结果，这可以避免不可重复读问题，但仍可能导致幻读问题。这个级别适用于需要确保数据的一致性，并且可以接受一定的并发性能损失的场景，例如银行转账操作。

4. **串行化（Serializable）**：这是最高的隔离级别。在这个级别，事务完全串行执行，可以避免所有的并发问题（包括脏读、不可重复读和幻读）。但由于事务是串行执行的，所以并发性能最低。这个级别适用于需要确保最高数据一致性，可以接受并发性能损失的场景，例如航空订票系统。

请注意，更高的隔离级别可以提供更好的数据一致性保证，但可能会降低并发性能。在实际应用中，需要根据具体的业务需求和系统性能要求，选择合适的隔离级别。

### 脏读、不可重复读、幻读

![脏读](assets/脏读.png)

![不可重复读](assets/不可重复读.png)

![幻读](assets/幻读.png)

"不可重复读"和"幻读"都是数据库并发控制中的问题，它们都是由于多个事务并发执行时对同一数据的读和写操作造成的。下面是对它们的区别的详细解释：

1. **不可重复读（Non-repeatable Read）**：不可重复读是指在一个事务内，多次读取同一数据返回的结果不一致。这是因为在这个事务读取数据的过程中，有其他事务也在修改这个数据。例如，事务T1读取了一条数据，然后事务T2修改了这条数据并提交，此时如果T1再次读取这条数据，就会发现数据已经被改变，这就是不可重复读。

2. **幻读（Phantom Read）**：幻读是指在一个事务内，执行相同的查询操作，返回的结果集不一致。这是因为在这个事务执行查询的过程中，有其他事务也在插入或删除数据。与不可重复读的区别在于，幻读关注的是一组数据（一个数据范围）而不是单条数据。例如，事务T1查询了一个范围的数据，然后事务T2在这个范围内插入了新的数据并提交，此时如果T1再次执行相同的查询，就会发现有新的数据出现，这就是幻读。

简单地说，不可重复读关注的是修改操作，而幻读关注的是插入和删除操作。SQL标准的"可重复读"隔离级别可以解决不可重复读的问题，而"串行化"隔离级别可以解决幻读的问题。

* 如果会话1、2同时开始，会话2中插入了数据，但是并没有提交，会话1在插入前，插入后读取的数据条数不一致，这种情况算是幻读还是脏读呢？
  * 会话2插入了数据但并没有提交，会话1在会话2插入数据前后读取的数据条数不一致。这种现象属于"脏读"（Dirty Read）。

