# 04.01 面向对象基础

## 面向对象的三大特征

* 封装（Encapsulation）
  * 对外部不可见
* 继承（Inheritance）
  * 扩展类的功能
* 多态（Polymorphism）
  * 对象的多态性

## 关于重载（Overload）、重写（Override）、多态

* 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，但是考虑到程序设计的一致性，重载时尽量保证方法的返回值类型相同。
* 重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。即外壳不变，核心重写。

  |区别点|重载方法|重写方法|
  |---------|------------|------------|
  |参数列表|必须修改|一定不能修改|
  |返回类型|可以修改，但最好相同|可以有可协变的返回类型|
  |异常|可以修改|可以减少或删除，一定不能抛出新的或者更广的异常|
  |访问|可以修改|一定不能做更严格的限制（可以降低限制）|
  > 参考 http://www.runoob.com/java/java-override-overload.html
  
* 关于重写（Override）的返回类型：
    * 返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。
    * 例如，假设`Employee`类有`public Employee getBuddy() {}`，在子类`Manager`中，可以按照如下所示的方式覆盖这个方法`public Manager getBuddy() {}`。这样就可以说，这两个`getBuddy`方法就有可协变的返回类型。
* **多态**是同一个行为具有多个不同表现形式或形态的能力。多态性是对象多种表现形式的体现。
  * 多态的三个必要条件：
    * 继承
    * 重写
    * 父类引用指向子类对象

## 内存划分：对象创建之初

* 类属于引用传递类型，同样存在着“栈内存-堆内存”的引用关系

  ![内存划分](./assets/memory-allocation.jpg)

  ```java
  Person per = new Person();
  ```

  * 声明对象：`Person per`，栈内存中保存对象名，只开辟了栈内存的对象是无法使用的，必须有堆内存的引用才可以使用。
  * 实例化对象：`new Person()`，在堆中开辟空间，所有的内容都是默认值。

* 进一步拆分上面一行代码，可以用如下形式：

  ```java
  Person per = null;     // 声明对象
  per = new Person();    // 实例化对象
  ```

## 引用传递

* 引用保存在栈内存
* 属性保存在堆内存
* 方法保存在全局代码区（此区域中的内容是所有对象共享的）

![内存划分](./assets/pointer.jpg)

注意：对象间的引用传递，实际上传递的就是**堆内存空间的使用权**。

## 垃圾产生与回收（GC）

![垃圾回收](./assets/gc.jpg)
